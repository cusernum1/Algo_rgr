1. Реализуйте АТД Стек на односвязном списке (forward_list).


2. Используя класс stack из STL решите следующую задачу.
(2565) В новом процессоре PDP-1 (Prime Data Processor) есть специальная операция dec(i,j,k)
, которая уменьшает все ячейки памяти с i
-й по j
-ю включительно на целое положительное число k
. Разработчики процессора не сделали операцию для очистки (обнуления) памяти. Необходимо, используя только указанную операцию, очистить n
 ячеек памяти, имеющих заданные начальные значения.
Напишите программу, которая определит наименьшее количество операций для обнуления памяти.
Первая строка ввода содержит одно целое число n
 (1≤n≤105
) – количество обнуляемых ячеек. Вторая строка ввода содержит n
 целых чисел ai
 (0≤ai≤109
, 0≤i<n
) – начальные значения ячеек памяти.
Вывести одно целое число – минимальное количество операций для обнуления памяти.


Абстрактный тип данных (АТД) — это математическая модель для типов данных, где тип данных определяется поведением (семантикой) с точки зрения пользователя данных, а именно в терминах возможных значений, возможных операций над данными этого типа и поведения этих операций.
Конкретные реализации АТД называются структурами данных. В С++ структуры данных реализуются как классы. В задаче 3 необходимо определить АТД, не нужно писать реализацию класса С++!

3. Определите АТД для хранения информации о таблице базы данных: столбцы (количество и названия столбцов), строки со значениями (все значения в строке таблицы имеют тип string), ключи для получения строк таблицы в некотором порядке (для упрощения ключ включает только один столбец, т.е. ключ - это имя или номер столбца, а строки таблицы можно получать последовательно по одной в порядке возрастания значения в указанном столбце). Перечислите методы АТД, обеспечивающие последовательный доступ к информации и её изменение, аргументы и возвращаемые значения каждого метода с комментариями.


4. Предложите структуры данных для представления АТД из задания 3. Перечислите поля, их типы и комментарии к каждому полю. Укажите оценку эффективности (амортизированную или среднюю) для каждого метода с учетом использованных структур данных. Хранимая в структуре информация не должна дублироваться.

Это отдельная задача. Не объединяете с задачей 3! Не пишите реализацию методов, нужно указать только оценку эффективности.


5. Напишите функцию для прямого (pre-order) обхода бинарного дерева, заданного следующей структурой:
struct node { int value; node *left, *right; };
К каждому значению, хранящемуся в дереве, функция применяет функцию, указанную в качестве аргумента:
void preorder(node *n, void (*f)(int));


6. Используя декартово дерево из лекций и vector из STL решите следующую задачу.
(2374) На соревнования на программированию прибыло слишком много команд, чтобы их можно было показать на мониторе. Поэтому Пете приходится отслеживать успехи своей любимой команды, используя информацию о принятых задачах команд. Команды в рейтинге сортируются в порядке уменьшения успешно сданных задач, а при равенстве количества задач - в порядке увеличения штрафного времени. Если равны и количество задач и время, то команды упорядочиваются по их номеру. Любимая команда Пети имеет номер 1.
Первая строка ввода содержит два целых числа — количество команд N
 (1≤N≤100000
) и количество событий M
 (1≤M≤100000
). Далее следует M
 строк, содержащих по два целых числа – информацию о произошедшем событии: номер команды t
 (1≤t≤N
), успешно сдавшей очередную задачу, и добавляемое штрафное время p
 (1≤p≤1000
).
Вывести M
 строк - в i
-й строке выводится рейтинг команды 1 после i
-го события.


7. Используя дерево отрезков решите следующую задачу.
(1969) Дана последовательность из N
 целых неотрицательных чисел. Ваша задача заключается в том, чтобы уметь выполнять три вида запросов:
1. + l
 r
 d
 -- прибавить ко всем числам на отрезке от l
 до r
 число d
 (1≤l≤r≤N
, 0≤d≤109
);
2. * l
 r
 d
 -- умножить все числа на отрезке от l
 до r
 число d
 (1≤l≤r≤N
, 0≤d≤109
);
3. ? p
 -вывести значение p
-го элемента в этой последовательности по модулю 109+7
 (1≤p≤N
).
В первой строке входного файла задано целое число N
. В следующей строке задано N
 целых неотрицательиых чисел, элементы последовательности. Каждое из этих чисел не превосходит 109
. В третьей строке задано число М
 -- количество запросов. В последующих M
 строках заданы запросы, соответствующие описанию из условия.
Для каждого запроса третьего вида выведите ответ на одной строке, в том порядке, в котором заданы запросы.


8. Используя set из STL напишите решение следующей задачи с эффективностью O(NlogN)
.
Дана последовательность из n
 различных целых чисел, которые постепенно добавляются в множество. После каждого добавления числа выведите ближайшие числа из множества, меньшее и большее добавленного. Если какого-либо числа не существует, выведите символ '*'.


9. Сравните время работы set и unordered_set из STL для операций поиска с количеством элементов N=100,10000,106,107
. Ключами являются строки из случайных букв от a до z длиной ровно 16. Результат оформить в виде таблицы, время в ns. Привести код, использованный для измерения времени для одного значения N
.


10. Определить АТД Полином, обеспечивающий метод calc для вычисления значения полинома в точке x
.

Реализовать полином через представление в виде вектора коэффициентов. В конструкторе задается набор коэффициентов a0,a1,...,an−1
. Определить операции + и *.


11. Определить АТД Разреженная матрица, обеспечивающий метод get(i,j
) для получения элемента матрицы и set(i,j,v
) для изменения (добавления) ненулевого элемента. В конструкторе задаются размеры матрицы.

Реализовать АТД через список списков vector<list<pair<int,double>>>. Определить эффективность операций + и * в зависимости от количества ненулевых элементов K
.


12. Определить АТД Матрица, обеспечивающий метод [i,j
] для доступа к элементам матрицы. В конструкторе задаются размеры матрицы.

Реализовать матрицу через vector размером N⋅M
. Определить операцию +. Сравнить время сложения матриц размером 1000×1000
, меняя порядок циклов (строки/столбцы и столбцы/строки) для уровня оптимизации O3. Результаты записать в таблицу, в которой будет указан порядок выполнения циклов и время выполнения в мкс.


13. Используя поиск в глубину, определите число компонент связности в графе, задаваемом следующим образом:

Как матрица N×M
 из символов латинского алфавита. Клетки считаются связными, если в них находится одинаковая буква и они имеют общую границу.


14. Используя поиск в ширину, решите задачу.
(1310) Королевство Флатландия имеет форму прямоугольника размером N×M
 клеток. Для защиты Флатландия в нескольких клетках были построены крепости, в которых размещены войска. При нападении войско из крепостей пешим маршем отправляется к месту появления врага. Войско может переходить только в соседнюю клетку, имеющую общую границу с клеткой, где находится войско. Такой переход выполняется за 1 единицу времени. Некоторые клетки Флатландии, в которых находятся леса и озера, горы и равнины, являются непроходимыми для войск. Король хочет выяснить за какое минимальное время войска могут гарантированно добраться до остальных клеток страны.
Напишите программу, которая вычисляет это время для заданной карты Флатландии.
Первая строка ввода содержит два целых числа N
 и M
 – размеры Флатландии. Далее следует N
 строк, содержащих по M
 символов '#' (непроходимая для войск клетка), '.' (удобная для передвижения войск клетка) и '*' (клетка с крепостью). Гарантируется, что войска могут добраться до всех клеток, обозначенных символом '.', из какой-либо крепости.
Вывести одно целое число – минимальное время для достижения войсками любой клетки страны, обозначенной символом '.'.


15. Напишите функцию для проверки, что в орграфе, заданном через матрицу смежности, существует эйлеров путь (путь, проходящий по всем дугам графа). Сам путь находить не нужно.


16. Есть n
 (2≤n≤10000
) городов, заданных своими координатами (xi, yi)
, i ∈ 1... n
, а также m
 (2≤m≤100000
) дорог, соединяющих города. Нужно построить дополнительное число дорог (возможно, нулевое), так чтобы из любого города можно было доехать в любой другой, двигаясь по дорогам. При этом сумма длин построенных дорог должна быть минимально возможной.
Укажите какой алгоритм построения минимального остовного дерева является более эффективным для решения этой задачи и обоснуйте свой выбор.


17. Укажите какой алгоритм нужно использовать для решения задачи и обоснуйте свой выбор. Из каких вершин и ребер граф будет состоять?
О последовательности A1,...,AN
 (1≤N≤200
), в которой каждое число от 1 до N
 встречается ровно один раз, известно M
 (0≤M≤40000
) ограничений вида:
1 i
 j
 x
 – наибольшее число в позициях между i
 и j
 (включительно) равно x

2 i
 j
 y
 – наименьшее число в позициях между i
 и j
 (включительно) равно y

Выведите любой вариант для такой последовательности.


18. Модифицируйте алгоритм Дейкстры для решения задачи:
В городе есть N
 площадей, соединенных M
 дорогами. Известна длина каждой дороги и номера площадей ai
, bi
 (1≤ai,bi≤N
), соединенных этой дорогой. Посчитайте количество способов добраться с площади A
 до площади B
 так, чтобы пройденный путь был минимален.


19. Напишите функцию для получения K
-го в порядке возрастания числа из двоичного файла, содержащего N
 (N>109
) 64-битных беззнаковых целых чисел. Функции передается имя файла с числами и K
. Можно считывать файл несколько раз. В памяти можно хранить не более 66000 64-битных чисел. Оцените эффективность вашего алгоритма.


20. Сравните время сортировки с помощью sort и timsort для последовательности из 106
 случайных чисел. Результаты оформить в виде таблицы.


21. Напишите функцию поиска подстроки методом Хорспула. Сравните время работы вашей функции с методом find и алгоритмом search с использованием boyer_moore_searcher из <functional> для текста размером 106
 символов и шаблона 104
 символов. Результаты представить в виде таблицы. Строки: 3 указанных алгоритма. Столбцы: 1) для случайного текста и шаблона; 2) текст 00...00, шаблон 00...01; 3) текст 00...00, шаблон 10...00.


22. Постройте сжатое суффиксное дерево для строки "течетречкапечетпечка" и найдите количеcтво различных подстрок в этой строке. Объясните способ подсчета с использованием суффиксного дерева.


23. Определите необходимые геометрические объекты и напишите следующую функцию
В декартовой системе координат на плоскости заданы координаты вершин треугольника и ещё одной точки. Определить, принадлежит ли эта точка треугольнику.

Для точки использовать класс из лекций и его методы.


24. Напишите функцию для проверки принадлежности точки невыпыклому многоугольнику. В качестве параметров функции передаются координаты точки и вектор координат вершин многоугольника против часовой стрелки.

Для точки использовать класс из лекций и его методы.


25. Напишите функцию разложения числа на простые множители.

