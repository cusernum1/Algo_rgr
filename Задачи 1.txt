

1. Реализуйте АТД Стек на односвязном списке (forward_list).

2. Используя класс stack из STL решите следующую задачу.
Напишите функцию с использованием стека для проверки корректности XML-строки. XML-строка называется корректной, если она может быть получена по следующим правилам:

    Пустая строка является корректной XML-строкой.
    Если A и B — корректные XML-строки, то строка AB, получающаяся приписыванием строки B в конец строки A, также является корректной XML-строкой.
    Если A — корректная XML-строка, то строка <X>A</X>, получающаяся приписыванием в начало A открывающегося тега, а в конец — закрывающегося с таким же именем, также является корректной XML-строкой. Здесь X — любая непустая строка из строчных букв латинского алфавита.

Например, представленные ниже строки:

<a></a>
<a><ab></ab><c></c></a>
<a></a><a></a><a></a>

являются корректными XML-строками, а такие строки как:

<a></b>
<a><b>
<a><b></a></b>

не являются корректными XML-строками.


Абстрактный тип данных (АТД) — это математическая модель для типов данных, где тип данных определяется поведением (семантикой) с точки зрения пользователя данных, а именно в терминах возможных значений, возможных операций над данными этого типа и поведения этих операций.
Конкретные реализации АТД называются структурами данных. В С++ структуры данных реализуются как классы. В задаче 3 необходимо определить АТД, не нужно писать реализацию класса С++!

3. Определите АТД для хранения информации о таблице базы данных: столбцы (количество и названия столбцов), строки со значениями (все значения в строке таблицы имеют тип string), ключи для получения строк таблицы в некотором порядке (для упрощения ключ включает только один столбец, т.е. ключ - это имя или номер столбца, а строки таблицы можно получать последовательно по одной в порядке возрастания значения в указанном столбце). Перечислите методы АТД, обеспечивающие последовательный доступ к информации и её изменение, аргументы и возвращаемые значения каждого метода с комментариями.

4. Предложите структуры данных для представления АТД из задания 3. Перечислите поля, их типы и комментарии к каждому полю. Укажите оценку эффективности (амортизированную или среднюю) для каждого метода с учетом использованных структур данных. Хранимая в структуре информация не должна дублироваться.

Это отдельная задача. Не объединяете с задачей 3! Не пишите реализацию методов, нужно указать только оценку эффективности.

5. Напишите функцию для прямого (pre-order) обхода бинарного дерева, заданного следующей структурой:
struct node { int value; node *left, *right; };
К каждому значению, хранящемуся в дереве, функция применяет функцию, указанную в качестве аргумента:
void preorder(node *n, void (*f)(int));

6. Используя декартово дерево из лекций решите следующую задачу.
(2379) Будем называть i
-й элемент последовательности a1, a2, ..., aN медианным, если количество элементов, меньших или равных ai среди элементов a1, a2, ..., ai−1, больше или равно количеству элементов, больших или равных ai среди элементов ai+1, ai+2, ..., aN

. В последовательности может быть несколько медианных элементов.
Напишите программу, которая находит минимальный индекс медианного элемента.

7. Используя дерево отрезков решите следующую задачу.
Есть массив, содержащий 100000 элементов, первоначально все элементы равны 0. В массиве производятся изменения элементов и требуется находить суммы части массива с i
-го по j-ый элементы.
В первой строке содержится число K (1≤K≤50000) -- количество запросов. Далее следует K строк, в каждой строке содержится либо команда "S i j v", где 1≤i≤j≤100000, −100≤v≤100, заменяющая значения элементов с i-го по j-й массива на v, либо команда "Q i j", где 1≤i≤j≤100000, требующая вывести сумму части массива с i-го по j

-ый элементы.
Для каждой команды 'Q' вывести на отдельной строке результат запроса

8. Используя map из STL напишите решение следующей задачи с эффективностью O(NlogN)
.
Дана последовательность из n

целых чисел. Найти непрерывную подпоследовательность максимальной длины, в которой нет одинаковых элементов. Вывести длину и начальный индекс найденной подпоследовательности.

9. Сравните время работы set и unordered_set из STL для операций добавления N
элементов, где N=100,10000,106,107. Ключами являются строки из случайных букв от a до z длиной ровно 16. Результат оформить в виде таблицы, время в ns. Привести код, использованный для измерения времени для одного значения N.
10. Определить АТД Полином, обеспечивающий метод calc для вычисления значения полинома в точке x.

Реализовать полином через представление на значениях в точках. В конструкторе задается набор значений y0,...,yn−1, x0 и Δx (xi=x0+i⋅Δx). Определить операцию +.

11. Определить АТД Разреженная матрица, обеспечивающий метод get(i,j) для получения элемента матрицы и set(i,j,v) для изменения (добавления) ненулевого элемента. В конструкторе задаются размеры матрицы.Реализовать АТД через список списков vector<list<pair<int,double>>>. Определить эффективность операций + и * в зависимости от количества ненулевых элементов K.

12. Определить АТД Матрица, обеспечивающий метод [i,j] для доступа к элементам матрицы. В конструкторе задаются размеры матрицы.Реализовать матрицу через vector размером N⋅M. Определить операцию +. Сравнить время сложения матриц 
размером 1000×1000, меняя порядок циклов (строки/столбцы и столбцы/строки) для уровня оптимизации O3. Результаты записать в таблицу, в которой будет указан порядок выполнения циклов и время выполнения в мкс.

13. Используя поиск в глубину, определите число компонент связности в графе, задаваемом следующим образом:
Как матрица N×M из символов латинского алфавита. Клетки считаются связными, если в них находится одинаковая буква и они имеют общую границу.

14. Используя поиск в ширину, решите задачу.
(1716) Стартовав с числа 1, нужно получить некоторое заданное число N
. На каждом шаге можно добавлять к текущему числу один из его делителей, чтобы получить новое число. Например, для первого шага у нас только один вариант: добавить 1 к 1 и получить 2. На втором шаге можно выбрать один из двух делителей и получить число 2+1=3 или 2+2=4. От числа 4 на третьем шаге можно перейти к числам 5, 6 или 8 в зависимости от выбранного делителя.Напишите программу, определяющую минимальное количество шагов для получения заданного числа N (2≤N≤105).

15. Напишите функцию для проверки отсутствия циклов в орграфе, заданном через списки смежных вершин.

16. Есть n(2≤n≤10000) городов, заданных своими координатами (xi, yi), i ∈ 1... n, а также m (2≤m≤100000) дорог, соединяющих города. Нужно построить дополнительное число дорог (возможно, нулевое), так чтобы из любого города можно было доехать в любой другой, двигаясь по дорогам. При этом сумма длин построенных дорог должна быть минимально возможной.
Укажите какой алгоритм построения минимального остовного дерева является более эффективным для решения этой задачи и обоснуйте свой выбор.

17. Укажите какой алгоритм нужно использовать для решения задачи и обоснуйте свой выбор. Из каких вершин и ребер граф будет состоять?
О последовательности A1,...,AN
(1≤N≤200), в которой каждое число от 1 до N встречается ровно один раз, известно M (0≤M≤40000) ограничений вида:
1 i j x – наибольшее число в позициях между i и j (включительно) равно x
2 i j y – наименьшее число в позициях между i и j (включительно) равно y
Выведите любой вариант для такой последовательности.

18. Модифицируйте алгоритм Дейкстры для решения задачи:
В городе есть N площадей, соединенных M дорогами с односторонним движением. В городе прошел снегопад. Задана скорость движения по неубранной дороге S1 и скорость движения по убранной дороге S2 (S2>S1). Известна длина каждой дороги Li, время начала уборки Ti и номера площадей ai, bi (1≤ai,bi≤N), соединенных этой дорогой. Уборка дороги выполняется со скоростью S1. Путешественнику необходимо добраться с площади A до площади B

так, чтобы время было минимальным.

19. Напишите функцию для поиска большой строки в большом текстовом файле. Функции передается имя файла с текстом и имя файла со строкой. Можно открывать один файл несколько раз и перемещать позицию чтения в файле. Нельзя загрузить в память полностью всю строку или текст. Оцените эффективность вашего алгоритма.

20. Сравните время сортировки с помощью sort и поразрядной сортировки для последовательности из 106

случайных беззнаковых целых чисел (за 1 разряд брать 1 байт числа). Результаты оформить в виде таблицы.

21. Напишите функцию поиска подстроки методом Хорспула. Сравните время работы вашей функции с методом find и алгоритмом search с использованием boyer_moore_searcher из <functional> для текста размером 106
символов и шаблона 104

символов. Результаты представить в виде таблицы. Строки: 3 указанных алгоритма. Столбцы: 1) для случайного текста и шаблона; 2) текст 00...00, шаблон 00...01; 3) текст 00...00, шаблон 10...00.

22. Постройте сжатое суффиксное дерево для строки "околоколаколокола" и найдите количеcтво различных подстрок в этой строке. Объясните способ подсчета с использованием суффиксного дерева.

23. Определите необходимые геометрические объекты и напишите следующую функцию
В декартовой системе координат на плоскости заданы координаты вершин треугольника и ещё одной точки. Определить, принадлежит ли эта точка треугольнику.

Для точки использовать класс из лекций и его методы.

24. Напишите функцию для нахождения стороны выпуклого многоугольника, ближайшей к его центру тяжести. В качестве параметра функции передается вектор координат вершин многоугольника против часовой стрелки. Многоугольник является сплошной фигурой.

25. Напишите функцию бинарного возведения в степень по модулю M.
